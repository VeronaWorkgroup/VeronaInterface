# Verona Player Module 2.0.0-alpha.5 documentation



This is one part of the Verona Online Assessment Standards. All messages are sent via the postMessage function of the html page. The player takes the page root of its parent as target (parent.window), and the application binds the function call to the iframe element of the player.
Most important, the message body carries as first parameter the operationId of the message.

## Table of Contents




* [Channels](#channels)










## Channels



<a name="channel-vopReadyNotification"></a>





#### Channel Parameters







###  `subscribe` vopReadyNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>apiVersion </td>
  <td>string</td>
  <td><p>This lets the application know what API version the player supports. If this does not fit the API version the application can offer, the player should not be used. An exception should be thrown.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>responseType </td>
  <td>string</td>
  <td><p>This string is important when the responses and the logs are processed. Every data transformation afterwards requires to know where the data came from. The type can be an ID of the player or a known data format.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "apiVersion": "string",
  "responseType": "string"
}
```








<a name="channel-vopStartCommand"></a>





#### Channel Parameters







###  `publish` vopStartCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>The session id flags all communication from this moment on. If a message has no or empty session id, it's not processed. The session id is unique and was generated by the application. Any simple algorithm would work. The session id helps to link the correct unit with the data of the message. Using the id of the player hosting html element is less reliable, because the element could be reused with another unit (via this StartCommand).</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitDefinition </td>
  <td>string</td>
  <td><p>The definition of the unit (if given) lets the player adapt. An audio player gets it's audio sequence, a choice player gets it's options...</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>responses </td>
  <td>object</td>
  <td><p>If there is any state what should be restored, then this is the information for that.</p>
</td>
  <td><em>Any</em></td>
</tr>









    
      
<tr>
  <td>playerConfig </td>
  <td>object</td>
  <td><p>This data supplies some information or instruction about this specific run of the unit (number, unit title, some behavioral data for the player).</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerConfig.unitNumber </td>
  <td>integer</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.unitTitle </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.unitId </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerConfig.stateReportPolicy </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>eager</code>, <code>on-demand</code></td>
</tr>









<tr>
  <td>playerConfig.logPolicy </td>
  <td></td>
  <td></td>
  <td><code>disabled</code>, <code>lean</code>, <code>rich</code></td>
</tr>











    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "unitDefinition": "string",
  "responses": {
    "property1": "string",
    "property2": "string"
  },
  "playerConfig": {
    "unitNumber": 1,
    "unitTitle": "string",
    "unitId": "string",
    "stateReportPolicy": "none",
    "logPolicy": "disabled"
  }
}
```








<a name="channel-vopStateChangedNotification"></a>





#### Channel Parameters







###  `subscribe` vopStateChangedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td><p>Ensures, that later arriving states are ignored.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td><p>To be stored, evaluated etc. This is the main yield, the responses.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.responses </td>
  <td>object</td>
  <td><p>These are all data needed for restoring the unit state after reload. This is also the basis for extracting the responses of the testee. Because the load of the whole state could be huge, we can split the state into chunks. So the data structure is &quot;key of chunk&quot; =&gt; &quot;chunk data&quot;. In order to restore the unit state or to analyse the response, all chunks are needed. If a chunk is sent twice, the first one (accourding to the time stamp) should be overwritten.</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code>, <code>complete-and-valid</code></td>
</tr>











    
      
<tr>
  <td>playerState </td>
  <td>object</td>
  <td><p>Information important only for the application to ensure the correct visual, such as navigation buttons.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerState.state </td>
  <td></td>
  <td></td>
  <td><code>running</code>, <code>stopped</code></td>
</tr>









<tr>
  <td>playerState.currentPage </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerState.validPages </td>
  <td>object</td>
  <td><p>These data are structured as &quot;page key&quot; =&gt; &quot;page label&quot;, so we have (1) keys for navigation commands or state notifications and (2) strings as labels of navigation buttons if needed.</p>
</td>
  <td><em>Any</em></td>
</tr>













    
      
<tr>
  <td>log </td>
  <td>array(object)</td>
  <td><p>Log entries (lean version) add some information to the response in order to understand the response process better or (rich version) let the analyst replay every change of the state.</p>
</td>
  <td><em>Any</em></td>
</tr>








<tr>
  <td>log.timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.key </td>
  <td>string</td>
  <td><p>This key might help to classify the events afterwards.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.content </td>
  <td>string</td>
  <td><p>Some information to specify the event.</p>
</td>
  <td><em>Any</em></td>
</tr>










    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "timeStamp": "2020-04-15T07:18:43Z",
  "unitState": {
    "responses": {
      "property1": "string",
      "property2": "string"
    },
    "presentationProgress": "none",
    "responseProgress": "none"
  },
  "playerState": {
    "state": "running",
    "currentPage": "string",
    "validPages": {
      "property1": "string",
      "property2": "string"
    }
  },
  "log": [
    {
      "timeStamp": "2020-04-15T07:18:43Z",
      "key": "string",
      "content": "string"
    }
  ]
}
```








<a name="channel-vopPageNavigationCommand"></a>





#### Channel Parameters







###  `publish` vopPageNavigationCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>target </td>
  <td>string</td>
  <td><p>Id of the page matching one of the validPages given to the application by the playerState data of the StateChangedNotification.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "target": "string"
}
```








<a name="channel-vopUnitNavigationRequestedNotification"></a>





#### Channel Parameters







###  `subscribe` vopUnitNavigationRequestedNotification

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>targetRelative </td>
  <td></td>
  <td><p>Refers to a unit relative to the position of the current unit or to the first or last unit. The key 'end' requests the finish of the test (close and go to the thank you page).</p>
</td>
  <td><code>next</code>, <code>previous</code>, <code>first</code>, <code>last</code>, <code>end</code></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "targetRelative": "next"
}
```








<a name="channel-vopGetStateRequest"></a>





#### Channel Parameters







###  `publish` vopGetStateRequest

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>stop </td>
  <td>boolean</td>
  <td><p>If true, the player should not accept any user interaction anymore to be sure, that all states of the unit are reported. Usually, you will do so just before unloading the player and prepare for the next unit.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "stop": true
}
```








<a name="channel-vopGetStateResponse"></a>





#### Channel Parameters







###  `subscribe` vopGetStateResponse

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>







    
      
<tr>
  <td>unitState </td>
  <td>object</td>
  <td><p>See StateChangedNotification.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>unitState.responses </td>
  <td>object</td>
  <td><p>These are all data needed for restoring the unit state after reload. This is also the basis for extracting the responses of the testee. Because the load of the whole state could be huge, we can split the state into chunks. So the data structure is &quot;key of chunk&quot; =&gt; &quot;chunk data&quot;. In order to restore the unit state or to analyse the response, all chunks are needed. If a chunk is sent twice, the first one (accourding to the time stamp) should be overwritten.</p>
</td>
  <td><em>Any</em></td>
</tr>











<tr>
  <td>unitState.presentationProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code></td>
</tr>









<tr>
  <td>unitState.responseProgress </td>
  <td></td>
  <td></td>
  <td><code>none</code>, <code>some</code>, <code>complete</code>, <code>complete-and-valid</code></td>
</tr>











    
      
<tr>
  <td>playerState </td>
  <td>object</td>
  <td><p>See StateChangedNotification.</p>
</td>
  <td><em>Any</em></td>
</tr>





<tr>
  <td>playerState.state </td>
  <td></td>
  <td></td>
  <td><code>running</code>, <code>stopped</code></td>
</tr>









<tr>
  <td>playerState.currentPage </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>playerState.validPages </td>
  <td>object</td>
  <td><p>These data are structured as &quot;page key&quot; =&gt; &quot;page label&quot;, so we have (1) keys for navigation commands or state notifications and (2) strings as labels of navigation buttons if needed.</p>
</td>
  <td><em>Any</em></td>
</tr>













    
      
<tr>
  <td>log </td>
  <td>array(object)</td>
  <td><p>See StateChangedNotification.</p>
</td>
  <td><em>Any</em></td>
</tr>








<tr>
  <td>log.timeStamp </td>
  <td>string</td>
  <td></td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.key </td>
  <td>string</td>
  <td><p>This key might help to classify the events afterwards.</p>
</td>
  <td><em>Any</em></td>
</tr>









<tr>
  <td>log.content </td>
  <td>string</td>
  <td><p>Some information to specify the event.</p>
</td>
  <td><em>Any</em></td>
</tr>










    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string",
  "timeStamp": "2020-04-15T07:18:43Z",
  "unitState": {
    "responses": {
      "property1": "string",
      "property2": "string"
    },
    "presentationProgress": "none",
    "responseProgress": "none"
  },
  "playerState": {
    "state": "running",
    "currentPage": "string",
    "validPages": {
      "property1": "string",
      "property2": "string"
    }
  },
  "log": [
    {
      "timeStamp": "2020-04-15T07:18:43Z",
      "key": "string",
      "content": "string"
    }
  ]
}
```








<a name="channel-vopStopCommand"></a>





#### Channel Parameters







###  `publish` vopStopCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string"
}
```








<a name="channel-vopContinueCommand"></a>





#### Channel Parameters







###  `publish` vopContinueCommand

#### Message








##### Payload




<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Accepted values</th>
    </tr>
  </thead>
  <tbody>
    
      
<tr>
  <td>sessionId </td>
  <td>string</td>
  <td><p>Unique identificator of the execution of the unit (one run). This id was generated by the application and first given to the player via StartCommand.</p>
</td>
  <td><em>Any</em></td>
</tr>







    
  </tbody>
</table>



###### Example of payload _(generated)_

```json
{
  "sessionId": "string"
}
```










